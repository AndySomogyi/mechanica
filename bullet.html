<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Bulletâ€™s Collision Algorithm &#8212; Mechanica 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.6/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.3.6/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lattice Structure" href="lattice.html" />
    <link rel="prev" title="Hello" href="test.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html">
          Mechanica</a>
        <span class="navbar-text navbar-version pull-left"><b>0.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Hello</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Bullet&#8217;s Collision Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="lattice.html">Lattice Structure</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Bullet&#8217;s Collision Algorithm</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#concepts">Concepts</a><ul>
<li><a class="reference internal" href="#collision-objects">Collision Objects</a></li>
<li><a class="reference internal" href="#collision-shapes">Collision Shapes</a></li>
<li><a class="reference internal" href="#broad-phase-collision">Broad Phase Collision</a></li>
<li><a class="reference internal" href="#narrow-phase-collision">Narrow Phase Collision</a></li>
<li><a class="reference internal" href="#aabb-bounding-box-hierarchy">AABB Bounding Box Hierarchy</a></li>
<li><a class="reference internal" href="#collision-pairs">Collision Pairs</a></li>
<li><a class="reference internal" href="#collision-manifold">Collision Manifold</a></li>
<li><a class="reference internal" href="#simulation-islands">Simulation Islands</a></li>
<li><a class="reference internal" href="#single-step">Single Step</a></li>
<li><a class="reference internal" href="#time-stepping">Time Stepping</a></li>
<li><a class="reference internal" href="#tracing-through-the-collision-detection-phase">Tracing Through the Collision Detection Phase</a></li>
<li><a class="reference internal" href="#bullet-callbacks-and-triggers">Bullet Callbacks and Triggers</a><ul>
<li><a class="reference internal" href="#contact-text">Contact Text</a></li>
<li><a class="reference internal" href="#contact-pair-test">Contact Pair Test</a></li>
<li><a class="reference internal" href="#contact-callbacks">Contact Callbacks</a></li>
<li><a class="reference internal" href="#triggers">Triggers</a></li>
<li><a class="reference internal" href="#triggers-and-the-btkinematiccharactercontroller">Triggers and the <code class="docutils literal"><span class="pre">btKinematicCharacterController</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#btbroadphasepair"><code class="code docutils literal"><span class="pre">btBroadphasePair</span></code></a></li>
<li><a class="reference internal" href="#btcollisionalgorithm"><code class="docutils literal"><span class="pre">btCollisionAlgorithm</span></code></a></li>
<li><a class="reference internal" href="#btpersistentmanifold"><code class="docutils literal"><span class="pre">btPersistentManifold</span></code></a></li>
<li><a class="reference internal" href="#btdiscretedynamicsworld"><code class="docutils literal"><span class="pre">btDiscreteDynamicsWorld</span></code></a></li>
<li><a class="reference internal" href="#btdynamicsworld"><code class="docutils literal"><span class="pre">btDynamicsWorld</span></code></a></li>
<li><a class="reference internal" href="#btcollisionworld"><code class="docutils literal"><span class="pre">btCollisionWorld</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="test.html" title="Previous Chapter: Hello"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Hello</span>
    </a>
  </li>
  <li>
    <a href="lattice.html" title="Next Chapter: Lattice Structure"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Lattice Structure &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="_sources/bullet.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="bullet-s-collision-algorithm">
<h1>Bullet&#8217;s Collision Algorithm</h1>
<div class="section" id="overview">
<h2>Overview</h2>
<p>This document attempts to better document the Bullet physics library, much of it based direclty on
the <a class="reference external" href="http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Tutorial_Articles/">Bullet Wiki</a></p>
<p>The bullet collision detection algorithm proceeds similarly to most rigid body / physics simulation
engines.  This document will cover the basic Bullet collision algorithm using discrete rigid
objects. Deformable (soft body) straight-forward extension. There are a number of key objects that
comprise a Bullet simulation.</p>
<ul>
<li><p class="first"><code class="code docutils literal"><span class="pre">btDiscreteDynamicsWorld</span></code>
The top level object that performs the main time stepping and connects the other pieces. Other
kinds of Bullet simulations such as soft body employ dynamics world objects that inherit from the
discrete dynamics world. Users must create the following objects and pass them to the discrete
dynamics world constructor.</p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">btDispatcher</span></code> foo foo
blas blah</p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">btBroadphaseInterface</span></code></p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">btConstraintSolver</span></code></p>
</li>
<li><p class="first"><code class="code docutils literal"><span class="pre">btCollisionConfiguration</span></code></p>
<p>blah</p>
</li>
</ul>
</div>
<div class="section" id="concepts">
<h2>Concepts</h2>
<div class="section" id="collision-objects">
<h3>Collision Objects</h3>
</div>
<div class="section" id="collision-shapes">
<h3>Collision Shapes</h3>
</div>
<div class="section" id="broad-phase-collision">
<h3>Broad Phase Collision</h3>
<p>Most collision detection frameworks break up collision detection into two phases, <em>broadphase</em> and
<em>narrowphase</em></p>
</div>
<div class="section" id="narrow-phase-collision">
<h3>Narrow Phase Collision</h3>
</div>
<div class="section" id="aabb-bounding-box-hierarchy">
<h3>AABB Bounding Box Hierarchy</h3>
<p>This is implemented by the btDbvtBroadphase in Bullet.
As the name suggests, this is a dynamic AABB tree. One useful feature of this broadphase is that the
structure adapts dynamically to the dimensions of the world and its contents. It is very well
optimized and a very good general purpose broadphase. It handles dynamic worlds where many objects
are in motion, and object addition and removal is faster than SAP.</p>
</div>
<div class="section" id="collision-pairs">
<h3>Collision Pairs</h3>
</div>
<div class="section" id="collision-manifold">
<h3>Collision Manifold</h3>
<p>In collision detection, a <em>manifold</em> defines a contact area between two objects. The set of
intersection points is referred to as the contact set or contact manifold, the latter term
appropriate when the intersection set is not a finite set but a continuum of points. For example,
the intersection set of a box sitting on a table is the set of points on a face of the box. When the
contact set is desired, I refer to this as a find-intersection query. As you would expect, in most
cases a find intersection query is more expensive than a test intersection query for a given pair of
objects.</p>
<p>Every actual, verified collision will result in an additional collision manifold. The collision
algorithms add a collision manifold to the dispatcher if a collision occurs. New contact manifolds
are always created by the <code class="code docutils literal"><span class="pre">btCollisionDispatcher::getNewManifold</span></code>, which all of the collision
algorithms call.</p>
<p>btPersistentManifold is a contact point cache, it stays persistent as long as objects are
overlapping in the broadphase. Those contact points are created by the collision narrow phase. The
cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one
point at a time. updates/refreshes old contact points, and throw them away if necessary (distance
becomes too large) reduces the cache to 4 points, when more then 4 points are added, using following
rules:</p>
<ul class="simple">
<li>the contact point with deepest penetration is always kept, and it tries to maximuze the area
covered by the points</li>
<li>note that some pairs of objects might have more then one contact manifold.</li>
</ul>
</div>
<div class="section" id="simulation-islands">
<h3>Simulation Islands</h3>
<p>Collision in general has a number of phases. Project the object forward. Figure out what collided,
then adjust and compensate for the collision.</p>
<p>The btCollisionObjectWrapper class &#8216;wraps&#8217; a btCollisionShape, btCollisionObject, along with a
worldTransform.</p>
<p>The <code class="code docutils literal"><span class="pre">btCollisionAlgorithm::processCollision</span></code> method as it&#8217;s name implies actually processs a
collision. The <code class="code docutils literal"><span class="pre">resoutOut</span></code> parameter is often, but not alwasy ingnored by the
caller. Basically, the <code class="code docutils literal"><span class="pre">btManifoldResult</span></code> objct holds onto a btPersistentManifold object. The
collision algoritm usually sets the btManifoldResult&#8217;s m_manifoldPtr to point to the persistent
manifold that&#8217;s owned by the collision algorithm.</p>
<p>The dispatcher, btCollisionDispatcher maintains a matrix of collision algoriths,
m_doubleDispatchContactPoints. The collision shape type is used to index this matrix and get the
collision algorithm for the appropriate pair in the <code class="code docutils literal"><span class="pre">btCollisionDispatcher::findAlgorithm</span></code>
method. This method creates a new collision algorithm for each potential collision. Each new
algorithm typically creates a new collision manifold from the dispatcher in the algorithm&#8217;s
constructor.</p>
</div>
<div class="section" id="single-step">
<h3>Single Step</h3>
<p>m_dynamicsWorld-&gt;stepSimulation(deltaTime);</p>
<p>int     btDiscreteDynamicsWorld::stepSimulation( btScalar timeStep,int maxSubSteps, btScalar
fixedTimeStep)</p>
<p>The interesting stuff</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">clampedSimulationSteps</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">internalSingleStepSimulation</span><span class="p">(</span><span class="n">fixedTimeStep</span><span class="p">);</span>
   <span class="n">synchronizeMotionStates</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The list of contact manifolds is created in, and owned by the dispatcher. The dispatcher is created
before the world, and handed to the world in it&#8217;s ctor.</p>
<p>All of the collision algorithms call <code class="code docutils literal"><span class="pre">btDispatcher::releaseManifold</span></code> in their destructors to
tell the dispatcher to remove this manifold.</p>
<p>The AABB tree gets updated in the <code class="code docutils literal"><span class="pre">btCollisionWorld::computeOverlappingPairs</span></code> method. This
method in turn calls <code class="code docutils literal"><span class="pre">btDbvtBroadphase::calculateOverlappingPairs</span></code>, which in turn calls
<code class="code docutils literal"><span class="pre">btDbvtBroadphase::collide</span></code>.</p>
<p>New broadphase collision pairs typically get created by the addOverlappingPair</p>
<p>The collision algorithm attached to a collision pair gets destroyed via a call to
<code class="code docutils literal"><span class="pre">btHashedOverlappingPairCache::cleanOverlappingPair</span></code>, and the collision pair gets destroyed
via a call to <code class="code docutils literal"><span class="pre">btHashedOverlappingPairCache::removeOverlappingPair</span></code>. This method gets called
when a pair of AABBs formerly in contact no longer contact each other. Hence, that&#8217;s why this method
gets a dispatcher as it&#8217;s last argument, as the dispatcher is needed to destroy the algorithm
attached to the collision pair.</p>
<p>The call sequence for updating the AAPP tree, and removing pairs that are no longer colliding is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">btCollisionWorld</span><span class="p">::</span><span class="n">performDiscreteCollisionDetection</span>
<span class="n">btCollisionWorld</span><span class="p">::</span><span class="n">computeOverlappingPairs</span>
<span class="n">btDbvtBroadphase</span><span class="p">::</span><span class="n">calculateOverlappingPairs</span>
<span class="n">btDbvtBroadphase</span><span class="p">::</span><span class="n">collide</span>
<span class="n">btHashedOverlappingPairCache</span><span class="p">::</span><span class="n">removeOverlappingPair</span>
</pre></div>
</div>
</div>
<div class="section" id="time-stepping">
<h3>Time Stepping</h3>
<p>The <code class="code docutils literal"><span class="pre">btDiscreteDynamicsWorld::internalSingleStepSimulation</span></code> is the main time step method. Each
time step consists of the following phases:</p>
<ul class="simple">
<li>Predict unconstrained motion,         ///apply gravity, predict motion</li>
<li>createPredictiveContacts(timeStep);</li>
<li>performDiscreteCollisionDetection();  ///perform collision detection</li>
<li>calculateSimulationIslands();</li>
<li>solveConstraints(getSolverInfo()); ///solve contact and other joint constraints</li>
<li>integrateTransforms(timeStep);        ///integrate transforms</li>
</ul>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">btDiscreteDynamicsWorld</span><span class="p">::</span><span class="n">internalSingleStepSimulation</span><span class="p">(</span><span class="n">btScalar</span> <span class="n">timeStep</span><span class="p">)</span>
<span class="p">{</span>

     <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">m_internalPreTickCallback</span><span class="p">)</span> <span class="p">{</span>
             <span class="p">(</span><span class="o">*</span><span class="n">m_internalPreTickCallback</span><span class="p">)(</span><span class="n">this</span><span class="p">,</span> <span class="n">timeStep</span><span class="p">);</span>
     <span class="p">}</span>

     <span class="o">///</span><span class="n">apply</span> <span class="n">gravity</span><span class="p">,</span> <span class="n">predict</span> <span class="n">motion</span>
     <span class="n">predictUnconstraintMotion</span><span class="p">(</span><span class="n">timeStep</span><span class="p">);</span>

     <span class="o">//</span> <span class="n">just</span> <span class="n">grab</span> <span class="n">the</span> <span class="n">dispatch</span> <span class="n">info</span>
     <span class="n">btDispatcherInfo</span><span class="o">&amp;</span> <span class="n">dispatchInfo</span> <span class="o">=</span> <span class="n">getDispatchInfo</span><span class="p">();</span>

     <span class="n">dispatchInfo</span><span class="o">.</span><span class="n">m_timeStep</span> <span class="o">=</span> <span class="n">timeStep</span><span class="p">;</span>
     <span class="n">dispatchInfo</span><span class="o">.</span><span class="n">m_stepCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">dispatchInfo</span><span class="o">.</span><span class="n">m_debugDraw</span> <span class="o">=</span> <span class="n">getDebugDrawer</span><span class="p">();</span>

     <span class="n">createPredictiveContacts</span><span class="p">(</span><span class="n">timeStep</span><span class="p">);</span>

     <span class="o">///</span><span class="n">perform</span> <span class="n">collision</span> <span class="n">detection</span>
     <span class="n">performDiscreteCollisionDetection</span><span class="p">();</span>

     <span class="n">calculateSimulationIslands</span><span class="p">();</span>

     <span class="n">getSolverInfo</span><span class="p">()</span><span class="o">.</span><span class="n">m_timeStep</span> <span class="o">=</span> <span class="n">timeStep</span><span class="p">;</span>

     <span class="o">///</span><span class="n">solve</span> <span class="n">contact</span> <span class="ow">and</span> <span class="n">other</span> <span class="n">joint</span> <span class="n">constraints</span>
     <span class="n">solveConstraints</span><span class="p">(</span><span class="n">getSolverInfo</span><span class="p">());</span>

     <span class="o">///</span><span class="n">CallbackTriggers</span><span class="p">();</span>

     <span class="o">///</span><span class="n">integrate</span> <span class="n">transforms</span>
     <span class="n">integrateTransforms</span><span class="p">(</span><span class="n">timeStep</span><span class="p">);</span>

     <span class="o">///</span><span class="n">update</span> <span class="n">vehicle</span> <span class="n">simulation</span>
     <span class="n">updateActions</span><span class="p">(</span><span class="n">timeStep</span><span class="p">);</span>

     <span class="n">updateActivationState</span><span class="p">(</span> <span class="n">timeStep</span> <span class="p">);</span>

     <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">m_internalTickCallback</span><span class="p">)</span> <span class="p">{</span>
         <span class="p">(</span> <span class="o">*</span> <span class="n">m_internalTickCallback</span><span class="p">)</span> <span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">timeStep</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">btDiscreteDynamicsWorld</span><span class="p">::</span><span class="n">createPredictiveContacts</span><span class="p">(</span><span class="n">btScalar</span> <span class="n">timeStep</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">releasePredictiveContacts</span><span class="p">();</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">m_nonStaticRigidBodies</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">createPredictiveContactsInternal</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">m_nonStaticRigidBodies</span><span class="p">[</span> <span class="mi">0</span> <span class="p">],</span> <span class="n">m_nonStaticRigidBodies</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">timeStep</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="tracing-through-the-collision-detection-phase">
<span id="coldet"></span><h3>Tracing Through the Collision Detection Phase</h3>
<p>Bullet makes extensive use of callback function, so it can be rather dificult to manually trace
through an execution pass. This section follows a discrete collision that occured between a pair of
rigid boxes. This section follows a call starting at
<code class="code docutils literal"><span class="pre">btDiscreteDynamicsWorld::internalSingleStepSimulation</span></code> and proceeding through the following
steps.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">btDiscreteDynamicsWorld</span><span class="p">::</span><span class="n">internalSingleStepSimulation</span>
<span class="n">btCollisionWorld</span><span class="p">::</span><span class="n">performDiscreteCollisionDetection</span>
<span class="n">btCollisionDispatcher</span><span class="p">::</span><span class="n">dispatchAllCollisionPairs</span>
<span class="n">btHashedOverlappingPairCache</span><span class="p">::</span><span class="n">processAllOverlappingPairs</span>
<span class="n">btCollisionPairCallback</span><span class="p">::</span><span class="n">processOverlap</span>
<span class="n">btCollisionDispatcher</span><span class="p">::</span><span class="n">defaultNearCallback</span>
<span class="n">btBoxBoxCollisionAlgorithm</span><span class="p">::</span><span class="n">processCollision</span>
</pre></div>
</div>
<p>The collision detection phase occurs after the unconstrained motion has been calculated. The
<code class="code docutils literal"><span class="pre">btCollisionWorld::performDiscreteCollisionDetection</span></code> first updates the dynamic AABB bounding
volume tree, computes the overlapping collision pairs, then performs the dispatch collision pairs
step.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">btCollisionWorld</span><span class="p">::</span><span class="n">performDiscreteCollisionDetection</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">btDispatcherInfo</span><span class="o">&amp;</span> <span class="n">dispatchInfo</span> <span class="o">=</span> <span class="n">getDispatchInfo</span><span class="p">();</span>

     <span class="n">updateAabbs</span><span class="p">();</span>

     <span class="n">computeOverlappingPairs</span><span class="p">();</span>

     <span class="n">btDispatcher</span><span class="o">*</span> <span class="n">dispatcher</span> <span class="o">=</span> <span class="n">getDispatcher</span><span class="p">();</span>
     <span class="n">dispatcher</span><span class="o">-&gt;</span><span class="n">dispatchAllCollisionPairs</span><span class="p">(</span>
        <span class="n">m_broadphasePairCache</span><span class="o">-&gt;</span><span class="n">getOverlappingPairCache</span><span class="p">(),</span><span class="n">dispatchInfo</span><span class="p">,</span><span class="n">m_dispatcher1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">btCollisionDispatcher</span><span class="p">::</span><span class="n">dispatchAllCollisionPairs</span><span class="p">(</span><span class="n">btOverlappingPairCache</span><span class="o">*</span> <span class="n">pairCache</span><span class="p">,</span>
   <span class="n">const</span> <span class="n">btDispatcherInfo</span><span class="o">&amp;</span> <span class="n">dispatchInfo</span><span class="p">,</span><span class="n">btDispatcher</span><span class="o">*</span> <span class="n">dispatcher</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">btCollisionPairCallback</span> <span class="n">collisionCallback</span><span class="p">(</span><span class="n">dispatchInfo</span><span class="p">,</span><span class="n">this</span><span class="p">);</span>

     <span class="n">pairCache</span><span class="o">-&gt;</span><span class="n">processAllOverlappingPairs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">collisionCallback</span><span class="p">,</span><span class="n">dispatcher</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">btHashedOverlappingPairCache</span><span class="p">::</span><span class="n">processAllOverlappingPairs</span><span class="p">(</span>
   <span class="n">btOverlapCallback</span><span class="o">*</span> <span class="n">callback</span><span class="p">,</span><span class="n">btDispatcher</span><span class="o">*</span> <span class="n">dispatcher</span><span class="p">)</span>
<span class="p">{</span>
   <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m_overlappingPairArray</span><span class="o">.</span><span class="n">size</span><span class="p">();)</span>
   <span class="p">{</span>
      <span class="n">btBroadphasePair</span><span class="o">*</span> <span class="n">pair</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_overlappingPairArray</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">callback</span><span class="o">-&gt;</span><span class="n">processOverlap</span><span class="p">(</span><span class="o">*</span><span class="n">pair</span><span class="p">))</span>
      <span class="p">{</span>
         <span class="n">removeOverlappingPair</span><span class="p">(</span><span class="n">pair</span><span class="o">-&gt;</span><span class="n">m_pProxy0</span><span class="p">,</span><span class="n">pair</span><span class="o">-&gt;</span><span class="n">m_pProxy1</span><span class="p">,</span><span class="n">dispatcher</span><span class="p">);</span>
         <span class="n">gOverlappingPairs</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span>
      <span class="p">{</span>
         <span class="n">i</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The btOverlapCallback defaults to btCollisionPairCallback, who&#8217;s processOverlap method looks like</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">virtual</span> <span class="nb">bool</span> <span class="n">processOverlap</span><span class="p">(</span><span class="n">btBroadphasePair</span><span class="o">&amp;</span> <span class="n">pair</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">(</span><span class="o">*</span><span class="n">m_dispatcher</span><span class="o">-&gt;</span><span class="n">getNearCallback</span><span class="p">())(</span><span class="n">pair</span><span class="p">,</span><span class="o">*</span><span class="n">m_dispatcher</span><span class="p">,</span><span class="n">m_dispatchInfo</span><span class="p">);</span>
   <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This calls the default btCollisionDispatcher::defaultNearCallback callback. Looks like every pair in
btHashedOverlappingPairCache::m_overlappingPairArray gets processed by the collision callback.</p>
<p>The btCollisionDispatcher::dispatchAllCollisionPairs calls this narrowphase nearcallback for each
pair that passes the &#8216;btCollisionDispatcher::needsCollision&#8217; test. You can customize this
nearcallback</p>
<p>First checks if objects really really can collide. If so, uses the dispatcher&#8217;s findAlgorithm as a
double dispatch (this is the matrix of collision algorithms) to find the correct algorithm
for the colliding pair.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//by default, Bullet will use this near callback
void btCollisionDispatcher::defaultNearCallback(btBroadphasePair&amp; collisionPair,
   btCollisionDispatcher&amp; dispatcher, const btDispatcherInfo&amp; dispatchInfo)
{
   btCollisionObject* colObj0 = (btCollisionObject*)collisionPair.m_pProxy0-&gt;m_clientObject;
   btCollisionObject* colObj1 = (btCollisionObject*)collisionPair.m_pProxy1-&gt;m_clientObject;

   if (dispatcher.needsCollision(colObj0,colObj1))
   {
      btCollisionObjectWrapper obj0Wrap(0,colObj0-&gt;getCollisionShape(),colObj0,colObj0-&gt;getWorldTransform(),-1,-1);
      btCollisionObjectWrapper obj1Wrap(0,colObj1-&gt;getCollisionShape(),colObj1,colObj1-&gt;getWorldTransform(),-1,-1);

      //dispatcher will keep algorithms persistent in the collision pair
      if (!collisionPair.m_algorithm)
      {
         collisionPair.m_algorithm = dispatcher.findAlgorithm(&amp;obj0Wrap,&amp;obj1Wrap,0, BT_CONTACT_POINT_ALGORITHMS);
      }

      if (collisionPair.m_algorithm)
      {
         btManifoldResult contactPointResult(&amp;obj0Wrap,&amp;obj1Wrap);

         if (dispatchInfo.m_dispatchFunc == btDispatcherInfo::DISPATCH_DISCRETE)
         {
            //discrete collision detection query
            collisionPair.m_algorithm-&gt;processCollision(&amp;obj0Wrap,&amp;obj1Wrap,dispatchInfo,&amp;contactPointResult);
         } else
         {
            //continuous collision detection query, time of impact (toi)
            btScalar toi = collisionPair.m_algorithm-&gt;calculateTimeOfImpact(colObj0,colObj1,dispatchInfo,&amp;contactPointResult);
            if (dispatchInfo.m_timeOfImpact &gt; toi)
               dispatchInfo.m_timeOfImpact = toi;

         }
      }
   }
}
</pre></div>
</div>
<p>Provides a way to check if complex collision objects really do collide with other objects, checks to
see if these objects are kinematic or static. If so, they don&#8217;t need to collide, and don&#8217;t get
processed above</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">btCollisionDispatcher</span><span class="p">::</span><span class="n">needsCollision</span><span class="p">(</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body0</span><span class="p">,</span><span class="n">const</span>
<span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body1</span><span class="p">)</span>
</pre></div>
</div>
<p>All of the collision algorithm concrete implementations contain a btPersistentManifold*
m_manifoldPtr; pointer. This is a pointer to a persistant manifold created and owned by the
dispatcher. The algorithm&#8217;s job is to process collisions, determine the  collision points, and add
them to this persistant manifold.</p>
<p>btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
It is persistent over frames</p>
<p>The collision algorithm shares a pointer to a persistent manifold, which is created by the collision
dispatcher&#8217;s getNewManifold method. The dispatcher retains a pointer to this manifold. All of the
collision algorithms call this method to get a pointer to a new shared manifold.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">btPersistentManifold</span><span class="o">*</span> <span class="n">btCollisionDispatcher</span><span class="p">::</span><span class="n">getNewManifold</span><span class="p">(</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span>
   <span class="n">body0</span><span class="p">,</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="bullet-callbacks-and-triggers">
<h3>Bullet Callbacks and Triggers</h3>
<p>The best way to determine if collisions happened between existing objects in the world, is to
iterate over all contact manifolds. This should be done during a
[<a class="reference external" href="http://www.bulletphysics.com/mediawiki-1.5.8/index.php?title=Stepping_The_World">http://www.bulletphysics.com/mediawiki-1.5.8/index.php?title=Stepping_The_World</a> simulation tick
(substep) callback], because contacts might be added and removed during several substeps of a single
stepSimulation call.</p>
<p>A contact manifold is a cache that contains all contact points between pairs of collision objects. A
good way is to iterate over all pairs of objects in the entire collision/dynamics world:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">Assume</span> <span class="n">world</span><span class="o">-&gt;</span><span class="n">stepSimulation</span> <span class="ow">or</span> <span class="n">world</span><span class="o">-&gt;</span><span class="n">performDiscreteCollisionDetection</span> <span class="n">has</span> <span class="n">been</span> <span class="n">called</span>

<span class="nb">int</span> <span class="n">numManifolds</span> <span class="o">=</span> <span class="n">world</span><span class="o">-&gt;</span><span class="n">getDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getNumManifolds</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numManifolds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">btPersistentManifold</span><span class="o">*</span> <span class="n">contactManifold</span> <span class="o">=</span>  <span class="n">world</span><span class="o">-&gt;</span><span class="n">getDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getManifoldByIndexInternal</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">obA</span> <span class="o">=</span> <span class="n">contactManifold</span><span class="o">-&gt;</span><span class="n">getBody0</span><span class="p">();</span>
    <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">obB</span> <span class="o">=</span> <span class="n">contactManifold</span><span class="o">-&gt;</span><span class="n">getBody1</span><span class="p">();</span>

    <span class="nb">int</span> <span class="n">numContacts</span> <span class="o">=</span> <span class="n">contactManifold</span><span class="o">-&gt;</span><span class="n">getNumContacts</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numContacts</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">contactManifold</span><span class="o">-&gt;</span><span class="n">getContactPoint</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">getDistance</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="n">f</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">const</span> <span class="n">btVector3</span><span class="o">&amp;</span> <span class="n">ptA</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">getPositionWorldOnA</span><span class="p">();</span>
            <span class="n">const</span> <span class="n">btVector3</span><span class="o">&amp;</span> <span class="n">ptB</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">getPositionWorldOnB</span><span class="p">();</span>
            <span class="n">const</span> <span class="n">btVector3</span><span class="o">&amp;</span> <span class="n">normalOnB</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">m_normalWorldOnB</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See Bullet/Demos/CollisionInterfaceDemo for a sample implementation.</p>
<ul class="simple">
<li>btGhostObject</li>
</ul>
<p>This type of collision object will keep track of its own overlapping pairs. This is much more
efficient than iterating through everything. For this example, we&#8217;ll use a btPairCachingGhostObject
since we want easy access to the pair cache of the ghost object. A regular btGhostObject can be used
for things like triggers where the details of the overlap don&#8217;t matter as much.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>btManifoldArray manifoldArray; btBroadphasePairArray&amp; pairArray =
ghostObject-&gt;getOverlappingPairCache()-&gt;getOverlappingPairArray(); int numPairs =
pairArray.size();

for (int i = 0; i &lt; numPairs; ++i) { manifoldArray.clear();

    const btBroadphasePair&amp; pair = pairArray[i];

    btBroadphasePair* collisionPair =  dynamicsWorld-&gt;getPairCache()-&gt;findPair(
        pair.m_pProxy0,pair.m_pProxy1);

    if (!collisionPair) continue;

    if (collisionPair-&gt;m_algorithm)
        collisionPair-&gt;m_algorithm-&gt;getAllContactManifolds(manifoldArray);

    for (int j = 0; j &lt; manifoldArray.size(); j++) {
        btPersistentManifold* manifold = manifoldArray[j];

        bool isFirstBody = manifold-&gt;getBody0() == ghostObject;

        btScalar direction = isFirstBody ? btScalar(-1.0) : btScalar(1.0);

        for (int p = 0; p &lt; manifold-&gt;getNumContacts(); ++p) {
           const btManifoldPoint&amp; pt = manifold-&gt;getContactPoint(p);

            if (pt.getDistance() &lt; 0.f) {
               const btVector3&amp; ptA = pt.getPositionWorldOnA(); const
               btVector3&amp; ptB = pt.getPositionWorldOnB(); const btVector3&amp; normalOnB =
               pt.m_normalWorldOnB;

               // handle collisions here
            }
        }
    }
}
</pre></div>
</div>
<p>For the ghost object to work correctly, we need to add a callback to our world.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">btDiscreteDynamicsWorld</span><span class="o">*</span> <span class="n">dynamicsWorld</span> <span class="o">=</span> <span class="n">CreateDiscreteDynamicsWorld</span><span class="p">();</span>
<span class="n">dynamicsWorld</span><span class="o">-&gt;</span><span class="n">getPairCache</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setInternalGhostPairCallback</span><span class="p">(</span>
<span class="n">new</span> <span class="n">btGhostPairCallback</span><span class="p">());</span>
</pre></div>
</div>
<p>Implementations of this concept can be found in the &#8216;BulletDemosCharacterDemo&#8217; and the
btKinematicCharacterController (in the recoverFromPenetration method).</p>
<div class="section" id="contact-text">
<h4>Contact Text</h4>
<p>Bullet 2.76 onwards let you perform an instant query on the world (btCollisionWorld or
btDiscreteDynamicsWorld) using the contactTest query. The contactTest query will peform a collision
test against all overlapping objects in the world, and produces the results using a callback. The
query object doesn&#8217;t need to be part of the world. In order for an efficient query on large worlds,
it is important that the broadphase aabbTest is accelerated, for example using the btDbvtBroadphase
or btAxisSweep3 broadphase.</p>
<p>An advantage of this method is that you can perform collision tests at a reduced temporal resolution
if you do not need collision tests at every physics tic.  It is also convenient to use with a
pre-existing object in the world, whereas btGhostObject would require synchronizing with the target
object.  However, a downside is that collision detection is being duplicated for the target object
(if it already exists in the world), so frequent or widespread collision tests may become less
efficient than iterating over previously generated collision pairs.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>struct ContactSensorCallback : public btCollisionWorld::ContactResultCallback {

   //! Constructor, pass whatever context you want to have available when processing contacts
   /*! You may also want to set m_collisionFilterGroup and m_collisionFilterMask
    *  (supplied by the superclass) for needsCollision() */
   ContactSensorCallback(btRigidBody&amp; tgtBody , YourContext&amp; context /*, ... */)
      : btCollisionWorld::ContactResultCallback(), body(tgtBody), ctxt(context) { }

   btRigidBody&amp; body; //!&lt; The body the sensor is monitoring
   YourContext&amp; ctxt; //!&lt; External information for contact processing

   //! If you don&#39;t want to consider collisions where the bodies are joined by a constraint, override needsCollision:
   /*! However, if you use a btCollisionObject for #body instead of a btRigidBody,
    *  then this is unnecessaryâ€”checkCollideWithOverride isn&#39;t available */
   virtual bool needsCollision(btBroadphaseProxy* proxy) const {
      // superclass will check m_collisionFilterGroup and m_collisionFilterMask
      if(!btCollisionWorld::ContactResultCallback::needsCollision(proxy))
         return false;
      // if passed filters, may also want to avoid contacts between constraints
      return body.checkCollideWithOverride(static_cast&lt;btCollisionObject*&gt;(proxy-&gt;m_clientObject));
   }

   //! Called with each contact for your own processing (e.g. test if contacts fall in within sensor parameters)
   virtual btScalar addSingleResult(btManifoldPoint&amp; cp,
   const btCollisionObjectWrapper* colObj0,int partId0,int index0,
   const btCollisionObjectWrapper* colObj1,int partId1,int index1) {
      btVector3 pt; // will be set to point of collision relative to body
      if(colObj0-&gt;m_collisionObject==&amp;body) {
         pt = cp.m_localPointA;
      } else {
         assert(colObj1-&gt;m_collisionObject==&amp;body &amp;&amp; &quot;body does not match either collision object&quot;);
         pt = cp.m_localPointB;
      }
      // do stuff with the collision point
      return 0; // There was a planned purpose for the return value of addSingleResult, but it is not used so you can ignore it.
   }
};

// USAGE:
btRigidBody* tgtBody /* = ... */;
YourContext foo;
ContactSensorCallback callback(*tgtBody, foo);
world-&gt;contactTest(tgtBody,callback);
</pre></div>
</div>
</div>
<div class="section" id="contact-pair-test">
<h4>Contact Pair Test</h4>
<p>Bullet 2.76 onwards provides the contactPairTest to perform collision detection between two specific
collision objects only. Contact results are passed on using the provided callback. They don&#8217;t need
to be inserted in the world. See btCollisionWorld::contactPairTest in
Bullet/src/BulletCollision/CollisionDispatch/btCollisionWorld.h for implementation details.</p>
</div>
<div class="section" id="contact-callbacks">
<h4>Contact Callbacks</h4>
<p>Be careful when using contact callbacks: They may be called too frequently for your purposes. Bullet
supports custom callbacks at various points in the collision system. The callbacks themselves are
very simply implemented as global variables that you set to point at appropriate functions. Before
you can expect them to be called you must set an appropriate flag in your rigid body:</p>
<dl class="docutils">
<dt>::</dt>
<dd><dl class="first last docutils">
<dt>mBody-&gt;setCollisionFlags(mBody-&gt;getCollisionFlags()</dt>
<dd><div class="first last line-block">
<div class="line">btCollisionObject::CF_CUSTOM_MATERIAL_CALLBACK);</div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>There are three collision callbacks:</p>
<p>gContactAddedCallback</p>
<p>This is called whenever a contact is added (note that the same contact may be added multiple times
before it is processed). From here, you can modify some properties (e.g. friction) of the contact
point.  &#8216;&#8217;&#8216;Note:&#8217;&#8216;&#8217; gContactAddedCallback does not appear to work when using multithreaded solvers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">ContactAddedCallback</span><span class="p">)(</span>
   <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">cp</span><span class="p">,</span>
   <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">colObj0</span><span class="p">,</span>
   <span class="nb">int</span> <span class="n">partId0</span><span class="p">,</span>
   <span class="nb">int</span> <span class="n">index0</span><span class="p">,</span>
   <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">colObj1</span><span class="p">,</span>
   <span class="nb">int</span> <span class="n">partId1</span><span class="p">,</span>
   <span class="nb">int</span> <span class="n">index1</span><span class="p">);</span>
</pre></div>
</div>
<p>As of the current implementation of Bullet (2.82), the return value of this function is ignored.</p>
<p>==gContactProcessedCallback==</p>
<p>This is called immediately after the collision has actually been processed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">ContactProcessedCallback</span><span class="p">)(</span>
   <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">cp</span><span class="p">,</span>
   <span class="n">void</span><span class="o">*</span> <span class="n">body0</span><span class="p">,</span><span class="n">void</span><span class="o">*</span> <span class="n">body1</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that &#8216;&#8217;body0&#8217;&#8217; and &#8216;&#8217;body1&#8217;&#8217; are pointers to the same btCollisionObjects as &#8216;&#8217;colObj0&#8217;&#8217; and
&#8216;&#8217;colObj1&#8217;&#8217; in the &#8216;&#8217;gContactAddedCallback&#8217;&#8217; (exactly why this function prototype is declared
differently is unclear).</p>
<p>As of the current implementation of Bullet (2.82), the return value of this function is ignored.</p>
<p><code class="docutils literal"><span class="pre">gContactDestroyedCallback</span></code></p>
<p>This is called immediately after the contact point is destroyed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="nb">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">ContactDestroyedCallback</span><span class="p">)(</span>
   <span class="n">void</span><span class="o">*</span> <span class="n">userPersistentData</span><span class="p">);</span>
</pre></div>
</div>
<p>The passed <code class="docutils literal"><span class="pre">userPersistentData</span></code> argument is the value of the &#8216;&#8217;m_userPersistentData&#8217;&#8217; member of
the <code class="docutils literal"><span class="pre">btManifoldPoint</span></code> which has been destroyed (this can be set in &#8216;&#8217;gContactAddedCallback&#8217;&#8217; or
&#8216;&#8217;gContactProcessedCallback&#8217;&#8216;).</p>
<p>&#8216;&#8217;&#8216;Note that gContactDestroyedCallback will not be called for any contact point unless
&#8216;&#8217;cp.m_userPersistentData&#8217;&#8217; is set!&#8217;&#8216;&#8217;  You must set this (to some value other than NULL) in a prior
contact added/processed callback in order to receive a destroyed callback.</p>
</div>
<div class="section" id="triggers">
<h4>Triggers</h4>
<p>Collision objects with a callback still have collision response with dynamic rigid bodies. In order
to use collision objects as trigger, you have to disable the collision response.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mBody</span><span class="o">-&gt;</span><span class="n">setCollisionFlags</span><span class="p">(</span><span class="n">mBody</span><span class="o">-&gt;</span><span class="n">getCollisionFlags</span><span class="p">()</span> <span class="o">|</span>
   <span class="n">btCollisionObject</span><span class="p">::</span><span class="n">CF_NO_CONTACT_RESPONSE</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="triggers-and-the-btkinematiccharactercontroller">
<h4>Triggers and the <code class="docutils literal"><span class="pre">btKinematicCharacterController</span></code></h4>
<p>The stock <code class="code docutils literal"><span class="pre">btKinematicCharacterController</span></code> doesn&#8217;t appear to properly behave with ghost
objects that have <code class="code docutils literal"><span class="pre">CF_NO_CONTACT_RESPONSE</span></code> set. It seems to ignore that flag and act as
if the objects don&#8217;t have that flag set.</p>
<p>The solution is to create a custom character controller based on the btKinematicCharacterController
class, and make a few changes, as detailed in this forum post:</p>
<p><a class="reference external" href="http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&amp;t=5684">http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&amp;t=5684</a></p>
<p>Add this IF into the method &#8216;&#8217;&#8216;btKinematicCharacterController::recoverFromPenetration&#8217;&#8216;&#8217;, under the
&lt;code&gt;btBroadphasePair* collisionPair = &amp;m_ghostObj...&lt;/code&gt; line:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//for trigger filtering
if (!static_cast&lt;btCollisionObject*&gt;(collisionPair-&gt;m_pProxy0-&gt;m_clientObject)-&gt;hasContactResponse() ||
   !static_cast&lt;btCollisionObject*&gt;(collisionPair-&gt;m_pProxy1-&gt;m_clientObject)-&gt;hasContactResponse())
   continue;
</pre></div>
</div>
<p>And add this IF to the beginning of &#8216;&#8217;&#8216;btKinematicClosestNotMeConvexResultCallback::addSingleResult&#8217;&#8216;&#8217;:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//for trigger filtering
if (!convexResult.m_hitCollisionObject-&gt;hasContactResponse())
   return btScalar(1.0);
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="classes">
<h2>Classes</h2>
<p>This section describes the key classes involved with Bullet collision detection.</p>
<div class="section" id="btbroadphasepair">
<span id="id1"></span><h3><code class="code docutils literal"><span class="pre">btBroadphasePair</span></code></h3>
<p><a class="reference external" href="https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h">https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/BroadphaseCollision/btBroadphaseProxy.h</a></p>
<p>The <code class="docutils literal"><span class="pre">btBroadphasePair</span></code> object represents a pair of pair of AABB-overlapping collision objects. The
<code class="docutils literal"><span class="pre">btBroadphasePair</span></code> exists as long as this pair of collision objects have operlappng AABB volumes.
A <code class="docutils literal"><span class="pre">btDispatcher</span></code> can search a <code class="docutils literal"><span class="pre">btCollisionAlgorithm</span></code> that performs exact/narrowphase collision
detection on the actual collision shapes.</p>
<p>The <code class="docutils literal"><span class="pre">btBroadphasePair</span></code> holds a reference to a collision algorithm. The collision algorithm
lifetime is the same as the broadphase pair. The <code class="code docutils literal"><span class="pre">btBroadphasePair</span></code></p>
<p>When the AABB&#8217;s of a pair of collision objects overlap, the <code class="code docutils literal"><span class="pre">btHashedOverlappingPairCache::addOverlappingPair</span></code>, in a call to
<code class="code docutils literal"><span class="pre">btHashedOverlappingPairCache::internalAddPair</span></code> creates a new <code class="code docutils literal"><span class="pre">btBroadphasePair</span></code>. This
new object is added to, and managed by a <code class="docutils literal"><span class="pre">btOverlappingPairCache</span></code>. The <code class="docutils literal"><span class="pre">btBroadphasePair</span></code>&#8216;s <code class="docutils literal"><span class="pre">m_algorithm</span></code> pointer is initially NULL.</p>
<p>The collision pair&#8217;s algorithm is created in the
dispatcher&#8217;s <code class="docutils literal"><span class="pre">findAlgorithm</span></code> method. The basic idea is that the collision algorithm exists as
long as a broadphase collision pair exists, the collision algorithm exists as long as a pair of
objects remain in AABB contact.</p>
<p>A simplified <code class="docutils literal"><span class="pre">btBroadphasePair</span></code></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">btBroadphasePair</span> <span class="p">{</span>
   <span class="n">btBroadphaseProxy</span><span class="o">*</span> <span class="n">m_pProxy0</span><span class="p">;</span>
   <span class="n">btBroadphaseProxy</span><span class="o">*</span> <span class="n">m_pProxy1</span><span class="p">;</span>
   <span class="n">mutable</span> <span class="n">btCollisionAlgorithm</span><span class="o">*</span> <span class="n">m_algorithm</span><span class="p">;</span>
   <span class="o">//</span><span class="n">don</span><span class="s1">&#39;t use this data, it will be removed in future version.</span>
   <span class="n">union</span> <span class="p">{</span> <span class="n">void</span><span class="o">*</span> <span class="n">m_internalInfo1</span><span class="p">;</span> <span class="nb">int</span> <span class="n">m_internalTmpValue</span><span class="p">;};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>some more stuff</p>
</div>
<div class="section" id="btcollisionalgorithm">
<span id="id2"></span><h3><code class="docutils literal"><span class="pre">btCollisionAlgorithm</span></code></h3>
<p><a class="reference external" href="https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h">https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h</a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">btCollisionAlgorithm</span> <span class="p">{</span>
<span class="n">protected</span><span class="p">:</span>
   <span class="n">btDispatcher</span><span class="o">*</span> <span class="n">m_dispatcher</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
   <span class="n">btCollisionAlgorithm</span><span class="p">()</span> <span class="p">{};</span>
   <span class="n">btCollisionAlgorithm</span><span class="p">(</span><span class="n">const</span> <span class="n">btCollisionAlgorithmConstructionInfo</span><span class="o">&amp;</span> <span class="n">ci</span><span class="p">);</span>
   <span class="n">virtual</span> <span class="o">~</span><span class="n">btCollisionAlgorithm</span><span class="p">()</span> <span class="p">{};</span>
   <span class="n">virtual</span> <span class="n">void</span> <span class="n">processCollision</span> <span class="p">(</span><span class="n">const</span> <span class="n">btCollisionObjectWrapper</span><span class="o">*</span> <span class="n">body0Wrap</span><span class="p">,</span>
      <span class="n">const</span> <span class="n">btCollisionObjectWrapper</span><span class="o">*</span> <span class="n">body1Wrap</span><span class="p">,</span>
      <span class="n">const</span> <span class="n">btDispatcherInfo</span><span class="o">&amp;</span> <span class="n">dispatchInfo</span><span class="p">,</span><span class="n">btManifoldResult</span><span class="o">*</span> <span class="n">resultOut</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">virtual</span> <span class="n">btScalar</span> <span class="n">calculateTimeOfImpact</span><span class="p">(</span><span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body0</span><span class="p">,</span>
      <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body1</span><span class="p">,</span><span class="n">const</span> <span class="n">btDispatcherInfo</span><span class="o">&amp;</span> <span class="n">dispatchInfo</span><span class="p">,</span>
      <span class="n">btManifoldResult</span><span class="o">*</span> <span class="n">resultOut</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">virtual</span> <span class="n">void</span> <span class="n">getAllContactManifolds</span><span class="p">(</span><span class="n">btManifoldArray</span><span class="o">&amp;</span> <span class="n">manifoldArray</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="btpersistentmanifold">
<span id="id3"></span><h3><code class="docutils literal"><span class="pre">btPersistentManifold</span></code></h3>
<p><a class="reference external" href="https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h#L63">https://github.com/bulletphysics/bullet3/blob/master/src/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h#L63</a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">btPersistentManifold</span> <span class="p">:</span> <span class="n">public</span> <span class="n">btTypedObject</span> <span class="p">{</span>
   <span class="n">btManifoldPoint</span> <span class="n">m_pointCache</span><span class="p">[</span><span class="n">MANIFOLD_CACHE_SIZE</span><span class="p">];</span>

   <span class="o">///</span> <span class="n">this</span> <span class="n">two</span> <span class="n">body</span> <span class="n">pointers</span> <span class="n">can</span> <span class="n">point</span> <span class="n">to</span> <span class="n">the</span> <span class="n">physics</span> <span class="n">rigidbody</span> <span class="n">class</span><span class="o">.</span>
   <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">m_body0</span><span class="p">;</span>
   <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">m_body1</span><span class="p">;</span>

   <span class="nb">int</span>       <span class="n">m_cachedPoints</span><span class="p">;</span>

   <span class="n">btScalar</span>  <span class="n">m_contactBreakingThreshold</span><span class="p">;</span>
   <span class="n">btScalar</span>  <span class="n">m_contactProcessingThreshold</span><span class="p">;</span>

   <span class="n">public</span><span class="p">:</span>
      <span class="nb">int</span>    <span class="n">m_companionIdA</span><span class="p">;</span>
      <span class="nb">int</span>    <span class="n">m_companionIdB</span><span class="p">;</span>

      <span class="nb">int</span> <span class="n">m_index1a</span><span class="p">;</span>

      <span class="n">btPersistentManifold</span><span class="p">();</span>

      <span class="n">btPersistentManifold</span><span class="p">(</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body0</span><span class="p">,</span> <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span>
         <span class="n">body1</span><span class="p">,</span><span class="nb">int</span> <span class="p">,</span> <span class="n">btScalar</span> <span class="n">contactBreakingThreshold</span><span class="p">,</span>
         <span class="n">btScalar</span> <span class="n">contactProcessingThreshold</span><span class="p">);</span>

     <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">getBody0</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_body0</span><span class="p">;}</span>
     <span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">getBody1</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_body1</span><span class="p">;}</span>

     <span class="n">void</span>    <span class="n">setBodies</span><span class="p">(</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body0</span><span class="p">,</span><span class="n">const</span> <span class="n">btCollisionObject</span><span class="o">*</span> <span class="n">body1</span><span class="p">);</span>

     <span class="n">void</span> <span class="n">clearUserCache</span><span class="p">(</span><span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>

     <span class="nb">int</span>     <span class="n">getNumContacts</span><span class="p">();</span>

     <span class="o">///</span> <span class="n">the</span> <span class="n">setNumContacts</span> <span class="n">API</span> <span class="ow">is</span> <span class="n">usually</span> <span class="ow">not</span> <span class="n">used</span><span class="p">,</span> <span class="k">except</span> <span class="n">when</span> <span class="n">you</span> <span class="n">gather</span><span class="o">/</span><span class="n">fill</span> <span class="nb">all</span> <span class="n">contacts</span> <span class="n">manually</span>
     <span class="n">void</span> <span class="n">setNumContacts</span><span class="p">(</span><span class="nb">int</span> <span class="n">cachedPoints</span><span class="p">);</span>

     <span class="n">const</span> <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">getContactPoint</span><span class="p">(</span><span class="nb">int</span> <span class="n">index</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

     <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">getContactPoint</span><span class="p">(</span><span class="nb">int</span> <span class="n">index</span><span class="p">);</span>

     <span class="o">///</span><span class="nd">@todo</span><span class="p">:</span> <span class="n">get</span> <span class="n">this</span> <span class="n">margin</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">current</span> <span class="n">physics</span> <span class="o">/</span> <span class="n">collision</span> <span class="n">environment</span>
     <span class="n">btScalar</span>        <span class="n">getContactBreakingThreshold</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>

     <span class="n">btScalar</span>        <span class="n">getContactProcessingThreshold</span><span class="p">()</span> <span class="n">const</span><span class="p">;</span>

     <span class="n">void</span> <span class="n">setContactBreakingThreshold</span><span class="p">(</span><span class="n">btScalar</span> <span class="n">contactBreakingThreshold</span><span class="p">);</span>

     <span class="n">void</span> <span class="n">setContactProcessingThreshold</span><span class="p">(</span><span class="n">btScalar</span>     <span class="n">contactProcessingThreshold</span><span class="p">);</span>

     <span class="nb">int</span> <span class="n">getCacheEntry</span><span class="p">(</span><span class="n">const</span> <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">newPoint</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

     <span class="nb">int</span> <span class="n">addManifoldPoint</span><span class="p">(</span> <span class="n">const</span> <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">newPoint</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isPredictive</span><span class="o">=</span><span class="n">false</span><span class="p">);</span>

     <span class="n">void</span> <span class="n">removeContactPoint</span> <span class="p">(</span><span class="nb">int</span> <span class="n">index</span><span class="p">);</span>

     <span class="n">void</span> <span class="n">replaceContactPoint</span><span class="p">(</span><span class="n">const</span> <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">newPoint</span><span class="p">,</span><span class="nb">int</span> <span class="n">insertIndex</span><span class="p">);</span>

     <span class="nb">bool</span> <span class="n">validContactDistance</span><span class="p">(</span><span class="n">const</span> <span class="n">btManifoldPoint</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="n">const</span><span class="p">;</span>

     <span class="o">///</span> <span class="n">calculated</span> <span class="n">new</span> <span class="n">worldspace</span> <span class="n">coordinates</span> <span class="ow">and</span> <span class="n">depth</span><span class="p">,</span> <span class="ow">and</span> <span class="n">reject</span> <span class="n">points</span> <span class="n">that</span> <span class="n">exceed</span> <span class="n">the</span> <span class="n">collision</span> <span class="n">margin</span>
     <span class="n">void</span>    <span class="n">refreshContactPoints</span><span class="p">(</span>  <span class="n">const</span> <span class="n">btTransform</span><span class="o">&amp;</span> <span class="n">trA</span><span class="p">,</span><span class="n">const</span> <span class="n">btTransform</span><span class="o">&amp;</span> <span class="n">trB</span><span class="p">);</span>

     <span class="n">void</span>    <span class="n">clearManifold</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="btdiscretedynamicsworld">
<h3><code class="docutils literal"><span class="pre">btDiscreteDynamicsWorld</span></code></h3>
<p><a class="reference external" href="https://github.com/bulletphysics/bullet3/blob/master/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h">https://github.com/bulletphysics/bullet3/blob/master/src/BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h</a></p>
<p>The <code class="docutils literal"><span class="pre">btDiscreteDynamicsWorld</span></code> is the main way to create discrete rigid body simulations. It inherits
from <code class="docutils literal"><span class="pre">btDynamicsWorld</span></code>, which in turn inherits from the base <code class="docutils literal"><span class="pre">btCollisionWorld</span></code>. The
btDiscreteDynamicsWorld determines the response to the identified collisions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">btDiscreteDynamicsWorld</span> <span class="p">:</span> <span class="n">public</span> <span class="n">btDynamicsWorld</span> <span class="p">{</span>
   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btTypedConstraint</span><span class="o">*&gt;</span>       <span class="n">m_sortedConstraints</span><span class="p">;</span>
   <span class="n">InplaceSolverIslandCallback</span><span class="o">*</span>                   <span class="n">m_solverIslandCallback</span><span class="p">;</span>
   <span class="n">btConstraintSolver</span><span class="o">*</span>                            <span class="n">m_constraintSolver</span><span class="p">;</span>
   <span class="n">btSimulationIslandManager</span><span class="o">*</span>                     <span class="n">m_islandManager</span><span class="p">;</span>
   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btTypedConstraint</span><span class="o">*&gt;</span>       <span class="n">m_constraints</span><span class="p">;</span>
   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btRigidBody</span><span class="o">*&gt;</span>             <span class="n">m_nonStaticRigidBodies</span><span class="p">;</span>
   <span class="n">btVector3</span>                                      <span class="n">m_gravity</span><span class="p">;</span>

   <span class="o">//</span><span class="k">for</span> <span class="n">variable</span> <span class="n">timesteps</span>
   <span class="n">btScalar</span>                                       <span class="n">m_localTime</span><span class="p">;</span>
   <span class="n">btScalar</span>                                       <span class="n">m_fixedTimeStep</span><span class="p">;</span>

   <span class="o">//</span><span class="k">for</span> <span class="n">variable</span> <span class="n">timesteps</span>
   <span class="nb">bool</span>                                           <span class="n">m_ownsIslandManager</span><span class="p">;</span>
   <span class="nb">bool</span>                                           <span class="n">m_ownsConstraintSolver</span><span class="p">;</span>
   <span class="nb">bool</span>                                           <span class="n">m_synchronizeAllMotionStates</span><span class="p">;</span>
   <span class="nb">bool</span>                                           <span class="n">m_applySpeculativeContactRestitution</span><span class="p">;</span>

   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btActionInterface</span><span class="o">*&gt;</span>       <span class="n">m_actions</span><span class="p">;</span>
   <span class="nb">int</span>                                            <span class="n">m_profileTimings</span><span class="p">;</span>
   <span class="nb">bool</span>                                           <span class="n">m_latencyMotionStateInterpolation</span><span class="p">;</span>
   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btPersistentManifold</span><span class="o">*&gt;</span>    <span class="n">m_predictiveManifolds</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">used</span> <span class="n">to</span> <span class="n">synchronize</span> <span class="n">threads</span> <span class="n">creating</span> <span class="n">predictive</span> <span class="n">contacts</span>
   <span class="n">btSpinMutex</span>                                    <span class="n">m_predictiveManifoldsMutex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="btdynamicsworld">
<h3><code class="docutils literal"><span class="pre">btDynamicsWorld</span></code></h3>
<p>The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete,
parallel, and continuous etc.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">btDynamicsWorld</span> <span class="p">:</span> <span class="n">public</span> <span class="n">btCollisionWorld</span> <span class="p">{</span>
   <span class="n">btInternalTickCallback</span>                         <span class="n">m_internalTickCallback</span><span class="p">;</span>
   <span class="n">btInternalTickCallback</span>                         <span class="n">m_internalPreTickCallback</span><span class="p">;</span>
   <span class="n">void</span><span class="o">*</span>                                          <span class="n">m_worldUserInfo</span><span class="p">;</span>
   <span class="n">btContactSolverInfo</span>                            <span class="n">m_solverInfo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="btcollisionworld">
<h3><code class="docutils literal"><span class="pre">btCollisionWorld</span></code></h3>
<p>The btCollisionWorld sets up the basic collision framework, it manages the broadphase and
dispatcher.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">btCollisionWorld</span> <span class="p">{</span>
   <span class="n">btAlignedObjectArray</span><span class="o">&lt;</span><span class="n">btCollisionObject</span><span class="o">*&gt;</span>       <span class="n">m_collisionObjects</span><span class="p">;</span>
   <span class="n">btDispatcher</span><span class="o">*</span>                                  <span class="n">m_dispatcher1</span><span class="p">;</span>
   <span class="n">btDispatcherInfo</span>                               <span class="n">m_dispatchInfo</span><span class="p">;</span>
   <span class="n">btBroadphaseInterface</span><span class="o">*</span>                         <span class="n">m_broadphasePairCache</span><span class="p">;</span>
   <span class="n">btIDebugDraw</span><span class="o">*</span>                                  <span class="n">m_debugDrawer</span><span class="p">;</span>

   <span class="o">///</span><span class="n">m_forceUpdateAllAabbs</span> <span class="n">can</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">false</span> <span class="k">as</span> <span class="n">an</span> <span class="n">optimization</span> <span class="n">to</span> <span class="n">only</span> <span class="n">update</span> <span class="n">active</span> <span class="nb">object</span> <span class="n">AABBs</span>
   <span class="o">///</span><span class="n">it</span> <span class="ow">is</span> <span class="n">true</span> <span class="n">by</span> <span class="n">default</span><span class="p">,</span> <span class="n">because</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">error</span><span class="o">-</span><span class="n">prone</span> <span class="p">(</span><span class="n">setting</span> <span class="n">the</span> <span class="n">position</span> <span class="n">of</span> <span class="n">static</span> <span class="n">objects</span> <span class="n">wouldn</span><span class="s1">&#39;t update their AABB)</span>
   <span class="nb">bool</span> <span class="n">m_forceUpdateAllAabbs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, Andy Somogyi.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>